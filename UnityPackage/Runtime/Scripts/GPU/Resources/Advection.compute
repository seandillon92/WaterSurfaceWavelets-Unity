#pragma enable_d3d11_debug_symbols
#pragma kernel Advection
#pragma kernel SetDefaulAmplitude
#pragma kernel Copy

Texture3D<float> Read;
Texture2D<float> heights;
Texture2D<float2> gradients;
RWTexture3D<float> Write;
float Default[16];
float deltaTime;
float groupSpeed;
SamplerState linearClampSampler;
static double tau = 6.28318530718;
static float theta_dx = tau / 16;
float dx;
float x_min;
float env_dx;

float2 idxToPos(float2 idx)
{
    return float2(x_min, x_min) + (idx + float2(0.5, 0.5)) * dx;
}

float2 posToGrid(float2 pos)
{
    return (pos - float2(x_min, x_min)) / dx - float2(0.5, 0.5);
}


float iTheta2Theta(float itheta)
{
    return (itheta + 0.5f) * theta_dx;
}

float Theta2iTheta(float theta)
{
    float r = (theta / theta_dx) - 0.5;
    if(r < 0)
        return 16 + r;
    return r;
}

float2 groupVelocity(uint3 id)
{
    float cg = groupSpeed;
    float theta = iTheta2Theta(id.z);
    return cg * float2(cos(theta), sin(theta));
}

float getHeight(float2 pos)
{
    uint x, y;
    heights.GetDimensions(x, y);
    float2 gridPos = pos / env_dx - float2(0.5, 0.5) + float2(x/2, y/2);
    float height =
        heights.SampleLevel(
            linearClampSampler,
            float2((gridPos.y + 0.5) / y, (gridPos.x + 0.5) / x),
    0);
    return height * dx;
}

float2 getGradient(float2 pos)
{
    uint x, y;
    float2 gradient;
    gradients.GetDimensions(x, y);
    
    float2 gridPos = pos / env_dx - float2(1, 0.5) + float2(x / 2, y / 2);
    gradient.x =
        gradients.SampleLevel(
            linearClampSampler,
            float2((gridPos.y + 0.5) / y, (gridPos.x + 0.5) / x), 0).r;
    
    gridPos = pos / env_dx - float2(0.5, 1) + float2(x / 2, y / 2);
    gradient.y = 
        gradients.SampleLevel(
            linearClampSampler,
            float2((gridPos.y + 0.5) / y, (gridPos.x + 0.5) / x), 0).g;
    
    return normalize(gradient.yx);
}

float3 boundaryReflection(float3 pos)
{
    float height = getHeight(pos.xy);
    if (height >= 0)
    {
        return pos;
    }
    
    float2 n = getGradient(pos.xy);
    float2 kdir = float2(cos(iTheta2Theta(pos.z)), sin(iTheta2Theta(pos.z)));
    pos.xy = pos.xy - 2.0f * height * n;
    kdir = kdir - 2.0f * dot(kdir, n) * n;
    float reflected_theta = atan2(kdir.y, kdir.x);
    float reflected_itheta = Theta2iTheta(reflected_theta);
    return float3(pos.xy, reflected_itheta);
}



[numthreads(2, 2, 8)]
void SetDefaulAmplitude(uint3 id : SV_DispatchThreadID)
{
    uint x, y, z;
    Write.GetDimensions(x, y, z);
    if (id.x == 0 || id.y == 0 || id.x == x -1 || id.y == y-1)
    {
        Write[id] = Default[id.z];
    }
    else
    {
        Write[id] = 0.0f;
    }
}


[numthreads(8,8,8)]
void Advection (uint3 id : SV_DispatchThreadID)
{
    float3 pos = id;
    pos.xy = idxToPos(id.xy);
    float height = getHeight(pos.xy);
    if (height >= 0)
    {
    
        uint x, y, z;
        Write.GetDimensions(x, y, z);
        float2 vel = groupVelocity(id);
        pos.x -= deltaTime * vel.x;
        pos.y -= deltaTime * vel.y;
        pos = boundaryReflection(pos);
        float2 gridPos = posToGrid(pos.xy);
        float3 samplingCoords =
            float3(
                (gridPos.x + 1.5) / x,
                (gridPos.y + 1.5) / y,
                (pos.z + 0.5) / z);
        
        float read = 
        Read.SampleLevel(
            linearClampSampler,
            samplingCoords, 0);

        Write[id + uint3(1, 1, 0)] = read;
    }
}

[numthreads(8,8,8)]
void Copy(uint3 id : SV_DispatchThreadID)
{
    id.x += 1;
    id.y += 1;
    Write[id] = Read[id];
}
