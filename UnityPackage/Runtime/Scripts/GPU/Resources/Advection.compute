#pragma enable_d3d11_debug_symbols
#pragma kernel Advection
#pragma kernel SetDefaulAmplitude
#pragma kernel Copy

Texture3D<float> Read;
Texture2D<float> heights;
Texture2D<float2> gradients;
RWTexture3D<float> Write;
float Default[16];
float deltaTime;
float groupSpeed;
SamplerState linearClampSampler;
static float tau = 6.28318530718;
static float theta_dx = tau / 16;
float inverse_dx;

float iTheta2Theta(uint itheta)
{
    return (itheta + 0.5) * theta_dx;
}

uint Theta2iTheta(float theta)
{
    return round((theta / theta_dx) - 0.5);
}

float2 groupVelocity(uint3 id)
{
    float cg = groupSpeed;
    float theta = iTheta2Theta(id.z);
    return cg * float2(cos(theta), sin(theta));
}

float getHeight(float2 pos)
{
    uint x, y, z;
    Write.GetDimensions(x, y, z);
    float height =
        heights.SampleLevel(
            linearClampSampler,
            float2((pos.y + 0.5) / y, (pos.x + 0.5) / x), 0);
    return height/inverse_dx;
}

float2 getGradient(float2 pos)
{
    uint x, y, z;
    Write.GetDimensions(x, y, z);
    float2 gradient =
        gradients.SampleLevel(
            linearClampSampler,
            float2((pos.y + 0.5) / y, (pos.x + 0.5) / x), 0);
    return gradient;
}

float3 boundaryReflection(float3 pos)
{
    float height = getHeight(pos.xy);
    if (height >= 0)
    {
        return pos;
    }
    
    float2 n = getGradient(pos.xy);
    float2 kdir = float2(cos(iTheta2Theta(pos.z)), sin(iTheta2Theta(pos.z)));
    pos.xy = pos.xy - 2.0 * height * n;
    kdir = kdir - 2.0 * (kdir * n) * n;
    float reflected_theta = atan2(kdir.y, kdir.x);
    uint reflected_itheta = Theta2iTheta(reflected_theta);
    return float3(pos.xy, reflected_itheta);
}



[numthreads(2, 2, 8)]
void SetDefaulAmplitude(uint3 id : SV_DispatchThreadID)
{
    uint x, y, z;
    Write.GetDimensions(x, y, z);
    if (id.x == 0 || id.y == 0 || id.x == x -1 || id.y == y-1)
    {
        Write[id] = Default[id.z];
    }
    else
    {
        Write[id] = 0.0f;
    }
}

[numthreads(8,8,8)]
void Advection (uint3 id : SV_DispatchThreadID)
{
    float height = getHeight(id.xy);
    if (height > 0)
    {
    
        uint x, y, z;
        Write.GetDimensions(x, y, z);
        float2 vel = groupVelocity(id);
        float3 trace_back = id;
        trace_back.x -= deltaTime * vel.x * inverse_dx;
        trace_back.y -= deltaTime * vel.y * inverse_dx;
        trace_back = boundaryReflection(trace_back);
        float read =
        Read.SampleLevel(
            linearClampSampler,
            float3((trace_back.x + 1.5) / x, (trace_back.y + 1.5) / y, (trace_back.z + 0.5) / z), 0);
        Write[id + uint3(1, 1, 0)] = read;
    }
}

[numthreads(8,8,8)]
void Copy(uint3 id : SV_DispatchThreadID)
{
    id.x += 1;
    id.y += 1;
    Write[id] = Read[id];
}
